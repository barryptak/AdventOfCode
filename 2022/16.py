"""
https://adventofcode.com/2022/day/16
"""
import functools
from utils.data import read_data, extract_ints
from utils.path_finding import dijkstra

USE_TEST_DATA = False
SPLIT_BY_LINE = True
data = read_data(USE_TEST_DATA, SPLIT_BY_LINE)

valves = []
valves_with_flow = set()
flow_rate = {}
tunnels = {}

MOVEMENT_COST = 1
OPEN_VALVE_COST = 1

# Read data
for line in data:
    parts = line.split()
    valve = parts[1]

    valves.append(valve)
    flow_rate[valve] = extract_ints(parts[4])[0]
    tunnels[valve] = [(t[:2], MOVEMENT_COST) for t in parts[9:]]

    if flow_rate[valve] > 0:
        valves_with_flow.add(valve)

valves_with_flow = frozenset(valves_with_flow)

# Get the distances from each node to every other
dists = {}
for valve in valves_with_flow | {"AA"}:
    dists[valve], _ = dijkstra(valve, valves, tunnels)

@functools.cache
def get_max_flow(starting_valve, valve_set, time_remaining):
    """
    Determines the max flow that can be achieved starting at valve and opening
    valves one at a time in the time remaining.
    """

    # We enter this function assuming that we have already opened the starting
    # valve. We don't have to special case the very first valve in the problem
    # as it has zero flow so it doesn't cause us issues.
    flow = flow_rate[starting_valve] * time_remaining

    # Determine the path from here that gives us the maximum flow
    best_flow = 0
    for next_valve in valve_set:
        # What time is left after moving to and opening next_valve?
        next_dist = dists[starting_valve][next_valve]
        next_time_remaining = time_remaining - (next_dist * MOVEMENT_COST) - OPEN_VALVE_COST

        # If there's time left then calculate the flow we get from opening
        # next_valve, and try opening another valve (calling this function
        # recursively to do so).
        if next_time_remaining > 0:
            next_valve_set = valve_set - {next_valve}
            next_flow = get_max_flow(next_valve, next_valve_set, next_time_remaining)
            if next_flow > best_flow:
                best_flow = next_flow

    return flow + best_flow


def all_paths(starting_valve, time_remaining, unvisited):
    """
    Generator function that returns every permutation of valid path from valve
    through the valves in unvisited until time runs out.
    Also returns the total flow generated by following each path.
    """

    # We assume that the starting node for this path is already open
    # so let's determine the contribution to the total flow from this valve
    flow = flow_rate[starting_valve] * time_remaining if time_remaining > 0 else 0

    # Iterate over all nodes that have not yet been visited and determine
    # what flow we achieve by following that path and opening then next node
    path_found = False
    for valve2 in unvisited:
        # Is it possible to move to valve2 and open it in the remaining time?
        cost = (dists[starting_valve][valve2] * MOVEMENT_COST) + OPEN_VALVE_COST
        new_time_remaining = time_remaining - cost
        if new_time_remaining > 0:
            # This is a valid path.
            # Get all of the paths possible from taking the path to valve2
            new_unvisited = frozenset(unvisited - {valve2})
            for path, path_flow in all_paths(valve2, new_time_remaining, new_unvisited):
                # Return the new path from this generator function
                yield {starting_valve} | path, flow + path_flow

    # If there's no further node that can be travelled to and opened in time
    # then just return the current node and flow only to conclude the path
    if not path_found:
        yield {starting_valve}, flow


# Part 1
# Determine the maximum flow that can be achieved through working alone
max_flow = get_max_flow("AA", valves_with_flow, 30)
print(max_flow)

# Part 2
# Determine the max flow that can be achieved by two people (or one person and
# an elephant) working together
# OMG this is slow. There must be a faster way!!!!
# I swear I did something that optimised this quite a bit, but then in the
# clean up it went back to the old speed...
# I can't be bothered figuring out what went wrong now.
# I had tried memoizing the generator and de-duping the frozensets but that seemed
# to make things a little slower, so... ¯\_(ツ)_/¯
max_flow_2 = 0
for path1, flow1 in all_paths("AA", 26, valves_with_flow):
    unvisited_valves = frozenset(valves_with_flow - path1)
    for path2, flow2 in all_paths("AA", 26, unvisited_valves):
        max_flow_2 = max(max_flow_2, flow1 + flow2)

print(max_flow_2)
